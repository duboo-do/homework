#include <stdio.h>
#include <string.h>

#define MAX_PRODUCTS 5
#define MAX_NAME_LENGTH 30

// 상품 정보를 저장할 구조체 정의
typedef struct {
    int id;
    char name[MAX_NAME_LENGTH];
    int price;
    int stock_in;  // 입고량
    int stock_out; // 판매량
    int total_sales; // 총 판매 금액
} Product;

Product products[MAX_PRODUCTS];  // 상품 배열

// 상품 갯수 초기화
int productCount = 0;

// 입고 처리
void inputStock() {
    int id, stock, price;
    char name[MAX_NAME_LENGTH];

    printf("상품 ID : ");
    scanf("%d", &id);
    getchar();  // 개행 문자 처리

    // 상품이 이미 있는지 확인
    for (int i = 0; i < productCount; i++) {
        if (products[i].id == id) {
            // 상품이 이미 존재하면 업데이트
            printf("상품이 이미 존재합니다. 상품 정보를 업데이트합니다.\n");
            printf("입고량 : ");
            scanf("%d", &stock);
            products[i].stock_in += stock;  // 기존 입고량에 추가
            printf("판매가격 : ");
            scanf("%d", &price);
            products[i].price = price;  // 판매가격 업데이트
            return;
        }
    }

    // 상품 배열이 꽉 차지 않았으면 새 상품 추가
    if (productCount < MAX_PRODUCTS) {
        // 새 상품 추가
        products[productCount].id = id;
        printf("상품명 : ");
        fgets(products[productCount].name, MAX_NAME_LENGTH, stdin);
        products[productCount].name[strcspn(products[productCount].name, "\n")] = '\0';  // 개행 문자 제거

        printf("입고량 : ");
        scanf("%d", &stock);
        printf("판매가격 : ");
        scanf("%d", &price);
        
        products[productCount].stock_in = stock;
        products[productCount].price = price;
        products[productCount].stock_out = 0;
        products[productCount].total_sales = 0;

        productCount++;  // 상품 갯수 증가
    } else {
        // 상품 배열이 꽉 찼을 경우
        printf("상품 갯수가 최대치인 5개를 초과할 수 없습니다.\n");
    }
}


// 판매 처리
void inputSales() {
    int id, quantity;
    
    printf("상품 ID : ");
    scanf("%d", &id);
    
    // 상품이 있는지 확인
    int found = 0;
    for (int i = 0; i < productCount; i++) {
        if (products[i].id == id) {
            found = 1;
            printf("판매량 : ");
            scanf("%d", &quantity);
            
            // 판매량이 재고를 초과x
            if (quantity > products[i].stock_in - products[i].stock_out) {
                printf("판매량이 재고를 초과합니다. 다시 입력해주세요.\n");
            } else {
                products[i].stock_out += quantity;
                products[i].total_sales += products[i].price * quantity;
                printf("상품 판매가 완료되었습니다.\n");
            }
            break;
        }
    }
    if (!found) {
        printf("상품 ID가 존재하지 않습니다.\n");
    }
}

// 개별 상품 정보 출력
void showIndividualProductInfo() {
    int id;
    printf("상품 ID : ");
    scanf("%d", &id);

    // 상품이 있는지 확인
    int found = 0;
    for (int i = 0; i < productCount; i++) {
        if (products[i].id == id) {
            found = 1;
            printf("상품명: %s\n", products[i].name);
            printf("판매가격: %d\n", products[i].price);
            printf("입고량: %d\n", products[i].stock_in);
            printf("판매량: %d\n", products[i].stock_out);
            printf("총판매금액: %d\n", products[i].total_sales);
            break;
        }
    }

    if (!found) {
        printf("상품 ID가 존재하지 않습니다.\n");
    }
}

// 전체 상품 정보 출력
void showAllProductInfo() {
    if (productCount == 0) {
        printf("등록된 상품이 없습니다.\n");
        return;
    }

    int totalStock = 0;        // 전체 재고량
    int totalSales = 0;        // 전체 총 판매금액
    int totalSoldItems = 0;    // 전체 판매량
    int minSales = __INT_MAX__; // 최소 판매량
    int maxSales = -1;         // 최대 판매량
    int minSalesId = -1, maxSalesId = -1; // 최소/최대 판매량 상품 ID
    char minSalesName[MAX_NAME_LENGTH], maxSalesName[MAX_NAME_LENGTH]; // 최소/최대 판매량 상품명
    int insufficientStockCount = 0; // 재고 부족 상품 개수

    printf("전체 상품 현황:\n");
    
    for (int i = 0; i < productCount; i++) {
        printf("상품 ID: %d\n", products[i].id);
        printf("상품명: %s\n", products[i].name);
        printf("판매가격: %d\n", products[i].price);
        printf("입고량: %d\n", products[i].stock_in);
        printf("판매량: %d\n", products[i].stock_out);
        printf("총판매금액: %d\n", products[i].total_sales);

        totalStock += products[i].stock_in;  // 전체 재고량 누적
        totalSales += products[i].total_sales;  // 전체 판매 금액 누적
        totalSoldItems += products[i].stock_out;  // 전체 판매량 누적

        // 판매량이 최소/최대인지 확인
        if (products[i].stock_out > maxSales) {
            maxSales = products[i].stock_out;
            maxSalesId = products[i].id;
            strcpy(maxSalesName, products[i].name);
        }
        if (products[i].stock_out < minSales) {
            minSales = products[i].stock_out;
            minSalesId = products[i].id;
            strcpy(minSalesName, products[i].name);
        }

        // 재고 부족 상품 체크
        if (products[i].stock_in - products[i].stock_out <= 0) {
            printf("상품 ID %d : 상품명: %s 재고부족(%d)\n", products[i].id, products[i].name, products[i].stock_in - products[i].stock_out);
            insufficientStockCount++;
        }

        printf("\n");
    }

    // 판매율 계산
    double saleRate = 0.0;
    if (totalStock > 0) {
        saleRate = ((double)totalSoldItems / totalStock) * 100;
    }

    // 전체 판매 금액과 판매율 출력
    printf("전체 총 판매금액: %d\n", totalSales);
    printf("판매율: %.2lf%%\n", saleRate);

    // 가장 많이 판매된 상품, 가장 적게 판매된 상품 출력
    printf("가장 많이 판매된 상품: ID %d, 상품명: %s, 판매량: %d\n", maxSalesId, maxSalesName, maxSales);
    printf("가장 적게 판매된 상품: ID %d, 상품명: %s, 판매량: %d\n", minSalesId, minSalesName, minSales);

    // 재고 부족 상품 개수 출력
    if (insufficientStockCount == 0) {
        printf("재고 부족 상품이 없습니다.\n");
    }
}


int main() {
    int choice;

    while (1) {
        printf("원하는 메뉴를 선택하세요.\n");
        printf("1. 입고\n2. 판매\n3. 개별현황\n4. 전체현황\n5. 종료\n");
        printf("입력: ");
        scanf("%d", &choice);
        getchar();  // 개행 문자 처리

        switch (choice) {
        case 1:  // 입고
            inputStock();
            break;
        case 2:  // 판매
            inputSales();
            break;
        case 3:  // 개별상품정보
            showIndividualProductInfo();
            break;
        case 4:  // 전체상품정보
            showAllProductInfo();
            break;
        case 5:  // 종료
            printf("프로그램을 종료합니다.\n");
            return 0;
        default:
            printf("잘못된 선택입니다.\n");
            break;
        }
    }

    return 0;
}
